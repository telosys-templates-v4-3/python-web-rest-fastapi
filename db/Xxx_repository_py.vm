#set( $env.language = 'Python' )
#parse("include/init_var_entity.vm")
#set($attributeNames = $fn.attributeNames($entity.attributes) )
# Domain dataclass for entity ${entity.name} 
# Created on $now.date ($now.time) generated by Telosys version $generator.version

from sqlalchemy.orm import Session
from typing import Optional, List

from db.${entLC}_record import ${recordType}
from domain.model.${entLC} import ${entity.name}

class ${repositoryType}:
    def __init__(self, db: Session):
        self.db = db

    #--- READ: GET ONE
    def get_by_pk(self, $fn.argumentsListWithType($entity.keyAttributes)) -> Optional[${entity.name}]:
        record = ( 
            self.db.query(${recordType})
#foreach( $attribute in $entity.keyAttributes )
            .filter(${recordType}.${attribute.name} == ${attribute.name})
#end
            .first()
            )
        if record:
            # return ${entity.name}.from_orm(record) # Old (Pydantic v1)
            return ${entity.name}.model_validate(record) # New (Pydantic v2)
        return None

    #--- READ: GET ALL
    def get_all(self) -> List[${entity.name}]:
        all_records = self.db.query(${recordType}).all()
        # return [${entity.name}.from_orm(record) for record in all_records] # Old (Pydantic v1)
        return [${entity.name}.model_validate(record) for record in all_records] # New (Pydantic v2)

    #--- CREATE 
    def create(self, ${entLC}: ${entity.name}) -> ${entity.name}:
        record = ${recordType}(
#foreach( $attribute in $entity.attributes )
#if( $foreach.hasNext )#set($end=",")#else#set($end="")#end
#if ( $attribute.isGeneratedValue() )
            # ${attribute.name} = 'generated value' (autoincrement or sequence) => do not use in INSERT 
#else
            ${attribute.name}=${entLC}.${attribute.name}${end}
#end
#end
        )
        self.db.add(record)
        self.db.commit()
        self.db.refresh(record)
        # return ${entity.name}.from_orm(record) # Old (Pydantic v1)
        return ${entity.name}.model_validate(record) # New (Pydantic v2)

    #--- UPDATE
    def update(self, ${entLC}: ${entity.name}) -> Optional[${entity.name}]:
        return self.update_by_pk($fn.argumentsListWithGetter(${entLC},$entity.keyAttributes), ${entLC})
    
    #--- UPDATE BY ID 
    def update_by_pk(self, $fn.argumentsListWithType($entity.keyAttributes), ${entLC}: ${entity.name}) -> Optional[${entity.name}]:
        record = ( 
            self.db.query(${recordType})
#foreach( $attribute in $entity.keyAttributes )
            .filter(${recordType}.${attribute.name} == ${attribute.name})
#end
            .first()
            )        
        if not record:
            return None
        # Update fields
#foreach( $attribute in $entity.nonKeyAttributes )
        record.$attribute.name = ${entLC}.$attribute.name
#end
        self.db.commit()
        self.db.refresh(record)
        # return ${entity.name}.from_orm(record) # Old (Pydantic v1)
        return ${entity.name}.model_validate(record) # New (Pydantic v2)

    #--- DELETE
    def delete_by_pk(self, $fn.argumentsListWithType($entity.keyAttributes)) -> bool:
        record = ( 
            self.db.query(${recordType})
#foreach( $attribute in $entity.keyAttributes )
            .filter(${recordType}.${attribute.name} == ${attribute.name})
#end
            .first()
            )
        if not record:
            return False # not found => not deleted
        self.db.delete(record)
        self.db.commit()
        return True # found and deleted
