#set( $env.language = 'Python' )
#parse("_include/standard-variables.vm")
#parse("_include/standard-macros.vm")
#parse("_include/standard-python-header.vm")
# REST DTO for entity ${entity.name} 
#
# Pydantic "BaseModel" offers the following features:
# . Validate input data (convert types when possible, generate errors otherwise)
# . Parse and serialize data to/from Python types (dict, JSON, etc.)
# . Provide default values and apply constraints
# Pydantic "Field" function is used to add metadata and validation constraints to model fields
# with FastAPI this metadata is directly reflected in the OpenAPI documentation.

from pydantic import BaseModel, Field
#basicImports($entity.attributes, false)
from domain.model.${entLC} import ${entity.name}

class ${dtoType}(BaseModel):
#foreach( $attribute in $entity.attributes )
$__#set($comment    = "")
$__#set($minLength  = "")
$__#set($maxLength  = "")
$__#set($ge  = "")
$__#set($le  = "")

$__#if( $attribute.isNotNull() )
$____#set($defaultOrRequired = "...")
$____#set($comment = "# required")
$__#else
$____#set($defaultOrRequired = "default=None")
$__#end
## 
$__#if ( $attribute.minLength != "" )
$____#set($minLength = ", min_length=${attribute.minLength}")
$__#end
$__#if ( $attribute.maxLength != "" )
$____#set($maxLength = ", max_length=${attribute.maxLength}")
$__#end
$__#if ( $attribute.minValue != "" )
$____#set($ge = ", ge=${attribute.minValue}")
$__#end
$__#if ( $attribute.maxValue != "" )
$____#set($le = ", le=${attribute.maxValue}")
$__#end
##    ${attribute.name}: ${attribute.type} = Field(default=None, title="${attribute.name}", description="")  # '...' => Required
##    ${attribute.name}: ${attribute.type} = Field(..., title="${attribute.name}", description="")  # '...' => Required
$__#if ( $attribute.name == $attribute.type )
## If the attribute name ==  "type hint" (eg "date: date") a Pydantic error occurs when calling "Field()" => do not call it
    ${attribute.name}: ${attribute.type} # cannot use field due to same name and type $comment
$__#else
## Standard case : no problem => use "Field()"
    ${attribute.name}: ${attribute.type} = Field(${defaultOrRequired}, title="${attribute.name}", description=""${minLength}${maxLength}${ge}${le})  $comment
$__#end
#end

# DTO class to domain class conversion
    def to_domain(self) -> ${entity.name}:
        # Specific conversion (to pass only the fields the domain cares about)
        return ${entity.name}(
#foreach( $attribute in $entity.attributes )
            ${attribute.name} = self.${attribute.name},
#end
        )
        # Short form (but not secure)
        # Pydantic throws an error if one of the DTO attributes doesn't exist in domain class
        # return ${entity.name}(**self.model_dump())