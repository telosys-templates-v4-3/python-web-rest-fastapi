#set( $env.language = 'Python' )
#parse("_include/standard-variables.vm")
#parse("_include/standard-macros.vm")
#parse("_include/standard-python-header.vm")
# REST ROUTER for entity ${entity.name} 
#set($attributeNames = $fn.attributeNames($entity.attributes) )

#basicImports($entity.keyAttributes)
import logging
## from typing import List, Optional
from typing import List
### from fastapi import APIRouter, Request, Response, Header, Query, Depends, status
from fastapi import APIRouter, Response, Depends, status, HTTPException
from domain.services.${service} import ${entity.name}Service, get_${entLC}_service
from rest.dto.${dto} import ${dtoType}

logger = logging.getLogger(__name__)

# API router for the '${entLC}' resource
router = APIRouter()

#------------------------------------------------------------------------------------
# GET ALL 
#------------------------------------------------------------------------------------
@router.get("",
        # summary: A short description of the route (displayed as the route's name in Swagger UI).
        summary="Get all", 
        # description: A detailed explanation, which supports Markdown formatting.
        description="Returns a collection with all resources",
        # tags: Organizes the routes in Swagger UI under specific headings. Useful for grouping routes logically 
        tags=["${entLC}"],
        responses={
            200: {"description": "OK."},
        })
async def get(
    # Service dependency injection
    ${service}: ${serviceType} = Depends(get_${service}),
    # Path parameters
    # (none)
    # Header parameters ("...": required, "None": optional)
    # xxx: str = Header(None, description="xxx (in header)", min_length=1, max_length=20, example="Foo"),
    # Query parameters for filtering ("...": required, "None": optional)
    # param: float = Query(None, title="Param 1", description="Filter with a parameter", example=10.0),
    ) -> List[${dtoType}]:
    logger.info("${entLC} router : get_all() ")

    all_list = ${service}.get_all()
    # domain to dto conversion
    result = []
    for o in all_list:
        # result.append(${dtoType}(id=o.id, name=o.name, price=o.price))
        result.append(${dtoType}($fn.joinWithTransformation($attributeNames, ", ", "%=o.%")))
    return result

#------------------------------------------------------------------------------------
# GET BY PRIMARY KEY  
#------------------------------------------------------------------------------------
@router.get("/$entity.keyAttributesNamesAsString('/', '{', '}')", 
        summary="Get a ${entLC} for the given id",
        description="Returns a ${entLC} or status 404 if not found",
        tags=["${entLC}"],
        responses={
            200: {"description": "OK."},
            404: {"description": "Not found."}, 
        })
async def get_by_pk(
    # Path parameters
    $fn.argumentsListWithType($entity.keyAttributes),
    # Service dependency injection
    ${service}: ${serviceType} = Depends(get_${service}),
    # Header parameters ("...": required, "None": optional)
    # xxx: str = Header(None, description="xxx (in header)", min_length=1, max_length=20, example="Foo"),
    ) -> ${dtoType}:
    #-----
    logger.info("${entLC} router : get_by_pk()")
    # Get by id using domain service 
    r = ${service}.get_by_pk($fn.argumentsList($entity.keyAttributes))
    if r is None:
        # If nothing found, return 404 status
        # OLD return Response(status_code=404)
        raise HTTPException(status_code=404, detail="${entity.name} not found")
    else:
        # If something found, return the payload
        # return ${dtoType}(id=r.id, name=r.name, price=r.price)
        return ${dtoType}($fn.joinWithTransformation($attributeNames, ", ", "%=r.%") )

#------------------------------------------------------------------------------------
# CREATE
#------------------------------------------------------------------------------------
@router.post("/", 
        summary="Creates a new ${entLC}",
        description="Creates a new ${entLC} and returns the created instance",
        tags=["${entLC}"],
        responses={
            200: {"description": "OK."},
            404: {"description": "Not found."}, 
        })
async def create(
    ${dto}: ${dtoType},
    # Service dependency injection
    ${service}: ${serviceType} = Depends(get_${service}),
    # Header parameters ("...": required, "None": optional)
    # xxx: str = Header(None, description="xxx (in header)", min_length=1, max_length=20, example="Foo"),
    ) -> ${dtoType}:
    #-----
    ${ent} = ${dto}.to_domain()   # conversion rest DTO to domain entity
    r = ${service}.create(${ent})
    if r is None:
        # No supposed to happen
        raise HTTPException(status_code=409, detail="${entity.name} not found") 
    else:
        # Created : return the payload
        return ${dtoType}($fn.joinWithTransformation($attributeNames, ", ", "%=r.%") )

#------------------------------------------------------------------------------------
# DELETE
#------------------------------------------------------------------------------------
@router.delete("/$entity.keyAttributesNamesAsString('/', '{', '}' )", 
        summary="Deletes a single ${entLC}",
        description="Deletes a single ${entLC} for the given id",
        tags=["${entLC}"],
        responses={
            204: {"description": "OK deleted"},
            404: {"description": "Not found"}, 
        })
async def delete_by_pk(
    # Path parameters
    $fn.argumentsListWithType($entity.keyAttributes),
    # Service dependency injection
    ${service}: ${serviceType} = Depends(get_${service}),
    ):
    # Delete by id using domain service 
    deleted  = ${service}.delete_by_pk($fn.argumentsList($entity.keyAttributes))
    if deleted :  
        # OK, deleted
        return Response(status_code=status.HTTP_204_NO_CONTENT) # status code, empty body
    else:  
        # Not found, not deleted
        return Response(status_code=status.HTTP_404_NOT_FOUND) # status code, empty body

#------------------------------------------------------------------------------------
# UPDATE
#------------------------------------------------------------------------------------
@router.put("/$entity.keyAttributesNamesAsString('/', '{', '}' )", 
    summary="Update a single ${entLC}",
    description="Updates a single ${entLC} for the given PK",
    tags=["${entLC}"],
    responses={
        204: {"description": "Successfully updated"},
        404: {"description": "Not found"},
    })
async def update_brand(
    # Path parameters
    $fn.argumentsListWithType($entity.keyAttributes),
    # Payload 
    ${dto}: ${dtoType},
    # Service dependency injection
    ${service}: ${serviceType} = Depends(get_${service}),
):
    ${ent} = ${dto}.to_domain()   # conversion rest DTO to domain entity
    updated = ${service}.update_by_pk($fn.argumentsList($entity.keyAttributes), ${ent})
    if updated is None: 
        # Not found, not updated
        return Response(status_code=status.HTTP_404_NOT_FOUND) # status code, empty body
    else:  
        # OK, updated
        return Response(status_code=status.HTTP_204_NO_CONTENT ) # status code, empty body

