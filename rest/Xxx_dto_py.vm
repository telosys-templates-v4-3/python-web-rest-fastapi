#set( $env.language = 'Python' )
#parse("include/init_var_entity.vm")
# REST DTO for entity ${entity.name} 
# Created on $now.date ($now.time) generated by Telosys version $generator.version
#
# Pydantic "BaseModel" offers the following features:
# . Validate input data (convert types when possible, generate errors otherwise)
# . Parse and serialize data to/from Python types (dict, JSON, etc.)
# . Provide default values and apply constraints
# Pydantic "Field" function is used to add metadata and validation constraints to model fields
# with FastAPI this metadata is directly reflected in the OpenAPI documentation.

#if ($entity.hasDecimalAttribute() )
from decimal import Decimal   
#end
#if ($entity.hasTemporalAttribute() )
from datetime import date, time, datetime
#end
#if ($entity.hasUuidAttribute() )
from uuid import UUID
#end
from pydantic import BaseModel, Field
from domain.model.${entLC} import ${entity.name}

class ${dtoType}(BaseModel):
#foreach( $attribute in $entity.attributes )
#set($comment    = "")
#set($minLength  = "")
#set($maxLength  = "")
#set($ge  = "")
#set($le  = "")

#if( $attribute.isNotNull() )
#set($defaultOrRequired = "...")
#set($comment = "# required")
#else
#set($defaultOrRequired = "default=None")
#end
## 
#if ( $attribute.minLength != "" )
#set($minLength = ", min_length=${attribute.minLength}")
#end
#if ( $attribute.maxLength != "" )
#set($maxLength = ", max_length=${attribute.maxLength}")
#end
#if ( $attribute.minValue != "" )
#set($ge = ", ge=${attribute.minValue}")
#end
#if ( $attribute.maxValue != "" )
#set($le = ", le=${attribute.maxValue}")
#end
##    ${attribute.name}: ${attribute.type} = Field(default=None, title="${attribute.name}", description="")  # '...' => Required
##    ${attribute.name}: ${attribute.type} = Field(..., title="${attribute.name}", description="")  # '...' => Required
#if ( $attribute.name == $attribute.type )
## If the attribute name ==  "type hint" (eg "date: date") a Pydantic error occurs when calling "Field()" => do not call it
    ${attribute.name}: ${attribute.type} # cannot use field due to same name and type $comment
#else
## Standard case : no problem => use "Field()"
    ${attribute.name}: ${attribute.type} = Field(${defaultOrRequired}, title="${attribute.name}", description=""${minLength}${maxLength}${ge}${le})  $comment
#end
#end

# DTO class to domain class conversion
    def to_domain(self) -> ${entity.name}:
        # Specific conversion (to pass only the fields the domain cares about)
        return ${entity.name}(
#foreach( $attribute in $entity.attributes )
            ${attribute.name} = self.${attribute.name},
#end
        )
        # Short form (but not secure)
        # Pydantic throws an error if one of the DTO attributes doesn't exist in domain class
        # return ${entity.name}(**self.model_dump())