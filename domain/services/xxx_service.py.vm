#set( $env.language = 'Python' )
#parse("_include/standard-variables.vm")
#parse("_include/standard-macros.vm")
#parse("_include/standard-python-header.vm")
# Domain service for entity ${entity.name} 
# The domain service contains business logic related to retrieving entities. 
# It uses the repository to fetch the data.

#basicImports($entity.keyAttributes, false)
from typing import List, Optional
from fastapi import Depends
from sqlalchemy.orm import Session

from domain.model.${entLC} import ${entity.name}
from db.db_session import get_db
from db.repositories.${entLC}_repository import $repositoryType

class $serviceType:
    # Dependency injection to provide the $repositoryType to the $serviceType
    def __init__(self, ${repository}: $repositoryType):
        self.${repository} = ${repository}

    # Get all entities
    def get_all(self) -> List[${entity.name}]:
        # Add any business logic here if necessary
        return self.${repository}.get_all()
    
    # Get a single entity by PK 
    def get_by_pk(self, $fn.argumentsListWithType($entity.keyAttributes)) -> ${entity.name}:
        # Add any business logic here if necessary
        return self.${repository}.get_by_pk($fn.argumentsList($entity.keyAttributes))

    # Get with specific criterion
    def get_by_xxx(self, xxx: Optional[str]=None) -> List[${entity.name}]:
        if xxx is None:
            return []  # empty list 
        else:
            return [] # TODO: return self.${repository}.get_by_xxx(xxx) 

    # Create
    def create(self, ${entLC}: ${entity.name}) -> ${entity.name}:
        return self.${repository}.create(${entLC})

    # Update 
    def update(self, ${entLC}: ${entity.name}) -> Optional[${entity.name}]:
        return self.${repository}.update(${entLC})

    # Update entity by PK  
    def update_by_pk(self, $fn.argumentsListWithType($entity.keyAttributes), ${entLC}: ${entity.name}) -> Optional[${entity.name}]:
        return self.${repository}.update_by_pk($fn.argumentsList($entity.keyAttributes), ${entLC})

    # Delete a single entity by PK
    def delete_by_pk(self, $fn.argumentsListWithType($entity.keyAttributes)) -> bool:
        return self.${repository}.delete_by_pk($fn.argumentsList($entity.keyAttributes))

# Dependency provider
# the repository depend on get_db(), so each request gets its own database session
# this way every HTTP request gets a fresh Session (no leaks, no global state)
def get_${service}(db: Session = Depends(get_db)) -> ${serviceType}:
    repo = ${repositoryType}(db)
    return ${serviceType}(repo)

